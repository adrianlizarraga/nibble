#include "cstring.h"
#include "x64_gen/regs.h"

// Linux System V ABI
static X64_Reg x64_linux_leaf_scratch_regs[] = {
    X64_R10, X64_R11, X64_RAX, X64_RDI, X64_RSI, X64_RDX, X64_RCX, X64_R8, X64_R9, // NOTE: Caller saved
    X64_R12, X64_R13, X64_R14, X64_R15, X64_RBX, // NOTE: Callee saved
};

static X64_Reg x64_linux_nonleaf_scratch_regs[] = {
    X64_R12, X64_R13, X64_R14, X64_R15, X64_RBX, // NOTE: Callee saved
    X64_R10, X64_R11, X64_RAX, X64_RDI, X64_RSI, X64_RDX, X64_RCX, X64_R8, X64_R9, // NOTE: Caller saved
};

static X64_Reg x64_linux_arg_regs[] = {X64_RDI, X64_RSI, X64_RDX, X64_RCX, X64_R8, X64_R9};

// Bit is 1 for caller saved registers: RAX, RCX, RDX, _, _, _, RSI, RDI, R8, R9, R10, R11, _, _, _, _
static const u32 x64_linux_caller_saved_reg_mask = 0x0FC7;

// Bit is 1 for arg registers: _, RCX, RDX, _, _, _, RSI, RDI, R8, R9, _, _, _, _, _, _
static const u32 x64_linux_arg_reg_mask = 0x03C6;

// Windows ABI
static X64_Reg x64_windows_leaf_scratch_regs[] = {
    X64_R10, X64_R11, X64_RAX, X64_RCX, X64_RDX, X64_R8,  X64_R9, // NOTE: Caller saved
    X64_R12, X64_R13, X64_R14, X64_R15, X64_RBX, X64_RSI, X64_RDI, // NOTE: Callee saved
};

static X64_Reg x64_windows_nonleaf_scratch_regs[] = {
    X64_R12, X64_R13, X64_R14, X64_R15, X64_RBX, X64_RSI, X64_RDI, // NOTE: Callee saved
    X64_R10, X64_R11, X64_RAX, X64_RCX, X64_RDX, X64_R8,  X64_R9, // NOTE: Caller saved
};

static X64_Reg x64_windows_arg_regs[] = {X64_RCX, X64_RDX, X64_R8, X64_R9};

// RAX, RCX, RDX, _, _, _, _, _, R8, R9, R10, R11, _, _, _, _
static const u32 x64_windows_caller_saved_reg_mask = 0x0F07;

// _, RCX, RDX, _, _, _, _, _, R8, R9, _, _, _, _, _, _
static const u32 x64_windows_arg_reg_mask = 0x0306;

static const char* x64_linux_startup_code =
    "SECTION .text\n"
    "global _start\n"
    "_start:  ; Program entry\n"
    "    xor rbp, rbp                 ; Mark the end of linked stacked frames\n"
    "    mov edi, dword [rsp]         ; Store argc into edi\n"
    "    lea rsi, [rsp + 8]           ; Store argv (address of first char*) into rsi\n"
    "    lea rdx, [rsp + 8*rdi + 16]  ; Store address of envp into rdx (8-bytes between argvs and envp)\n"
    "    xor eax, eax                 ; Clear eax (just in case for variadic functions)\n"
    "    call main                    ; Call program main()\n"
    "    mov edi, eax                 ; Move main's return value into rdi for exit syscall\n"
    "    mov rax, 60                  ; Move id of exit syscall into rax\n"
    "    syscall                      ; Call exit syscall\n"
    "\n"
    "global _nibble_#writeout\n"
    "_nibble_#writeout:\n"
    "    push rbp \n"
    "    mov rbp, rsp\n"
    "\n"
    "    xchg rdi, rsi ; swap args -> bytes in rsi, count in rdi\n"
    "    mov rax, 1    ; write syscall\n"
    "    mov rdx, rdi  ; count in rdx\n"
    "    mov rdi, 1    ; STDOUT_FILENO in rdi\n"
    "\n"
    "    syscall\n"
    "\n"
    "    mov rsp, rbp\n"
    "    pop rbp\n"
    "    ret\n\n"
    "global _nibble_#readin\n"
    "_nibble_#readin:\n"
    "    push rbp \n"
    "    mov rbp, rsp\n"
    "\n"
    "    xchg rdi, rsi ; swap args -> bytes in rsi, count in rdi\n"
    "    mov rax, 0    ; read syscall\n"
    "    mov rdx, rdi  ; count in rdx\n"
    "    mov rdi, 0    ; STDIN_FILENO in rdi\n"
    "\n"
    "    syscall\n"
    "\n"
    "    mov rsp, rbp\n"
    "    pop rbp\n"
    "    ret\n";

static const char* x64_windows_startup_code =
    "SECTION .text\n"
    "extern GetCommandLineA\n"
    "extern LocalAlloc\n"
    "extern LocalFree\n"
    "extern GetStdHandle\n"
    "extern ReadFile\n"
    "extern WriteFile\n\n"
    "global _start\n"
    "_start:  ; Program entry\n"
    "push rbp\n"
    "mov rbp, rsp\n"
    "sub rsp, 16 + 32                ; Alloc space for locals and shadow space (for all called funcs)\n"
    "                                ; argc: int (rbp - 4), retval : int (rbp - 8), argv: ^^char (rbp - 16)\n\n"
    "lea rcx, [rbp - 4]              ; rcx = ^argc\n"
    "call _nibble_get_win64_cmd_args ; rax = copy of argv\n"
    "mov qword [rbp - 16], rax       ; store argv to free later\n\n"
    "mov rcx, qword [rbp - 4]        ; rcx = argc\n"
    "mov rdx, rax                    ; rdx = argv\n"
    "xor eax, eax                    ; Clear eax (just in case for variadic functions)\n"
    "call main                       ; Call program main()\n"
    "mov dword [rbp - 8], eax        ; store retval\n\n"
    "mov rcx, qword [rbp - 16]       ; rcx = argv\n"
    "call LocalFree                  ; free argv\n\n"
    "mov eax, dword [rbp - 8]        ; Return retval from main()\n\n"
    "mov rsp, rbp\n"
    "pop rbp\n"
    "ret\n\n"
	"; proc _nibble_get_win64_cmd_args(argc: ^int) => ^^char;\n"
	"; Sets argc and returns argv\n"
	"; argv should be freed with LocalFree()\n"
	"global _nibble_get_win64_cmd_args\n"
	"_nibble_get_win64_cmd_args:\n"
	    "push    r14\n"
	    "push    rsi\n"
	    "push    rdi\n"
	    "push    rbx\n"
	    "sub     rsp, 40\n"
	    "mov     r14, rcx\n"
	    "call    GetCommandLineA\n"
	    "mov     rdi, rax\n"
	    "mov     r8b, byte [rax]\n"
	    "cmp     r8b, 34\n"
	    "jne     .L_win64_args_1\n"
	    "lea     rcx, [rdi + 1]\n"
	".L_win64_args_6:\n"
	    "mov     al, byte [rcx]\n"
	    "test    al, al\n"
	    "je      .L_win64_args_8\n"
	    "inc     rcx\n"
	    "cmp     al, 34\n"
	    "jne     .L_win64_args_6\n"
	    "jmp     .L_win64_args_8\n"
	".L_win64_args_1:\n"
	    "mov rax, 4294967809\n"
	    "mov     edx, r8d\n"
	    "mov     rcx, rdi\n"
	".L_win64_args_2:\n"
	    "cmp     dl, 32\n"
	    "ja      .L_win64_args_4\n"
	    "movzx   edx, dl\n"
	    "bt      rax, rdx\n"
	    "jb      .L_win64_args_8\n"
	".L_win64_args_4:\n"
	    "mov     dl, byte [rcx + 1]\n"
	    "inc     rcx\n"
	    "jmp     .L_win64_args_2\n"
	".L_win64_args_86:\n"
	    "inc     rcx\n"
	".L_win64_args_8:\n"
	    "mov     al, byte [rcx]\n"
	    "cmp     al, 9\n"
	    "je      .L_win64_args_86\n"
	    "cmp     al, 32\n"
	    "je      .L_win64_args_86\n"
	    "test    al, al\n"
	    "jne     .L_win64_args_12\n"
	    "mov     edx, 1\n"
	    "jmp     .L_win64_args_13\n"
	".L_win64_args_12:\n"
	    "mov     edx, 2\n"
	".L_win64_args_13:\n"
	    "xor     esi, esi\n"
	    "xor     ebx, ebx\n"
	".L_win64_args_14:\n"
	    "cmp     al, 32\n"
	    "je      .L_win64_args_23\n"
	    "test    al, al\n"
	    "je      .L_win64_args_16\n"
	    "cmp     al, 9\n"
	    "jne     .L_win64_args_20\n"
	    "test    esi, esi\n"
	    "je      .L_win64_args_24\n"
	".L_win64_args_20:\n"
	    "cmp     al, 34\n"
	    "je      .L_win64_args_28\n"
	    "cmp     al, 92\n"
	    "jne     .L_win64_args_31\n"
	    "inc     ebx\n"
	    "inc     rcx\n"
	    "jmp     .L_win64_args_33\n"
	".L_win64_args_23:\n"
	    "test    esi, esi\n"
	    "je      .L_win64_args_24\n"
	".L_win64_args_31:\n"
	    "inc     rcx\n"
	    "jmp     .L_win64_args_32\n"
	".L_win64_args_87:\n"
	    "mov     al, byte [rcx + 1]\n"
	    "inc     rcx\n"
	".L_win64_args_24:\n"
	    "cmp     al, 9\n"
	    "je      .L_win64_args_87\n"
	    "cmp     al, 32\n"
	    "je      .L_win64_args_87\n"
	    "test    al, al\n"
	    "je      .L_win64_args_32\n"
	    "inc     edx\n"
	".L_win64_args_32:\n"
	    "xor     ebx, ebx\n"
	".L_win64_args_33:\n"
	    "mov     al, byte [rcx]\n"
	    "jmp     .L_win64_args_14\n"
	".L_win64_args_28:\n"
	    "not     ebx\n"
	    "and     ebx, 1\n"
	    "lea     eax, [rsi + rbx]\n"
	    "dec     eax\n"
	".L_win64_args_29:\n"
	    "inc     eax\n"
	    "cmp     byte [rcx + 1], 34\n"
	    "lea     rcx, [rcx + 1]\n"
	    "je      .L_win64_args_29\n"
	    "movsxd  rsi, eax\n"
	    "imul    rax, rsi, 1431655766\n"
	    "mov     rbx, rax\n"
	    "shr     rbx, 63\n"
	    "shr     rax, 32\n"
	    "add     eax, ebx\n"
	    "lea     eax, [rax + 2*rax]\n"
	    "sub     esi, eax\n"
	    "xor     ebx, ebx\n"
	    "cmp     esi, 2\n"
	    "cmove   esi, ebx\n"
	    "jmp     .L_win64_args_33\n"
	".L_win64_args_16:\n"
	    "test    r8b, r8b\n"
	    "je      .L_win64_args_17\n"
	    "mov     ecx, 1\n"
	".L_win64_args_35:\n"
	    "lea     rax, [rcx + 1]\n"
	    "cmp     byte [rdi + rcx], 0\n"
	    "mov     rcx, rax\n"
	    "jne     .L_win64_args_35\n"
	    "jmp     .L_win64_args_36\n"
	".L_win64_args_17:\n"
	    "mov     eax, 1\n"
	".L_win64_args_36:\n"
	    "movsxd  rsi, edx\n"
	    "lea     rdx, [rax + 8*rsi]\n"
	    "add     rdx, 8\n"
	    "xor     ecx, ecx\n"
	    "call    LocalAlloc\n"
	    "test    rax, rax\n"
	    "je      .L_win64_args_37\n"
	    "lea     rsi, [rax + 8*rsi]\n"
	    "add     rsi, 8\n"
	    "mov     cl, byte [rdi]\n"
	    "test    cl, cl\n"
	    "je      .L_win64_args_39\n"
	    "inc     rdi\n"
	    "mov     rdx, rsi\n"
	".L_win64_args_41:\n"
	    "mov     byte [rdx], cl\n"
	    "inc     rdx\n"
	    "mov     cl, byte [rdi]\n"
	    "inc     rdi\n"
	    "test    cl, cl\n"
	    "jne     .L_win64_args_41\n"
	    "jmp     .L_win64_args_42\n"
	".L_win64_args_37:\n"
	    "xor     eax, eax\n"
	    "jmp     .L_win64_args_85\n"
	".L_win64_args_39:\n"
	    "mov     rdx, rsi\n"
	".L_win64_args_42:\n"
	    "mov     byte [rdx], 0\n"
	    "mov     qword [rax], rsi\n"
	    "mov     cl, byte [rsi]\n"
	    "cmp     cl, 34\n"
	    "jne     .L_win64_args_43\n"
	".L_win64_args_48:\n"
	    "mov     cl, byte [rsi + 1]\n"
	    "test    cl, cl\n"
	    "je      .L_win64_args_52\n"
	    "cmp     cl, 34\n"
	    "je      .L_win64_args_50\n"
	    "mov     byte [rsi], cl\n"
	    "inc     rsi\n"
	    "jmp     .L_win64_args_48\n"
	".L_win64_args_43:\n"
	    "mov rdx, 4294967809\n"
	".L_win64_args_44:\n"
	    "cmp     cl, 32\n"
	    "ja      .L_win64_args_46\n"
	    "movzx   ebx, cl\n"
	    "bt      rdx, rbx\n"
	    "jb      .L_win64_args_51\n"
	".L_win64_args_46:\n"
	    "mov     cl, byte [rsi + 1]\n"
	    "inc     rsi\n"
	    "jmp     .L_win64_args_44\n"
	".L_win64_args_51:\n"
	    "cmp     cl, 1\n"
	    "mov     rcx, rsi\n"
	    "sbb     rcx, -1\n"
	    "jmp     .L_win64_args_53\n"
	".L_win64_args_52:\n"
	    "lea     rcx, [rsi + 1]\n"
	    "jmp     .L_win64_args_53\n"
	".L_win64_args_50:\n"
	    "lea     rcx, [rsi + 2]\n"
	".L_win64_args_53:\n"
	    "mov     byte [rsi], 0\n"
	    "inc     rsi\n"
	".L_win64_args_54:\n"
	    "mov     dl, byte [rcx]\n"
	    "cmp     dl, 9\n"
	    "je      .L_win64_args_88\n"
	    "cmp     dl, 32\n"
	    "jne     .L_win64_args_56\n"
	".L_win64_args_88:\n"
	    "inc     rcx\n"
	    "jmp     .L_win64_args_54\n"
	".L_win64_args_56:\n"
	    "test    dl, dl\n"
	    "jne     .L_win64_args_58\n"
	    "mov     rcx, rax\n"
	    "add     rcx, 8\n"
	    "mov     r9d, 1\n"
	    "jmp     .L_win64_args_84\n"
	".L_win64_args_58:\n"
	    "mov     qword [rax + 8], rsi\n"
	    "xor     r8d, r8d\n"
	    "mov     r9d, 2\n"
	    "xor     edi, edi\n"
	".L_win64_args_82:\n"
	    "xor     ebx, ebx\n"
	".L_win64_args_60:\n"
	    "mov     dl, byte [rcx]\n"
	    "cmp     dl, 32\n"
	    "je      .L_win64_args_68\n"
	    "test    dl, dl\n"
	    "je      .L_win64_args_83\n"
	    "cmp     dl, 9\n"
	    "jne     .L_win64_args_64\n"
	    "test    edi, edi\n"
	    "je      .L_win64_args_69\n"
	".L_win64_args_64:\n"
	    "cmp     dl, 92\n"
	    "jne     .L_win64_args_65\n"
	    "inc     rcx\n"
	    "mov     byte [rsi], 92\n"
	    "inc     rsi\n"
	    "inc     ebx\n"
	    "jmp     .L_win64_args_60\n"
	".L_win64_args_68:\n"
	    "test    edi, edi\n"
	    "jne     .L_win64_args_81\n"
	".L_win64_args_69:\n"
	    "mov     byte [rsi], 0\n"
	    "inc     rsi\n"
	".L_win64_args_70:\n"
	    "inc     rcx\n"
	    "mov     dl, byte [rcx]\n"
	    "cmp     dl, 9\n"
	    "je      .L_win64_args_70\n"
	    "cmp     dl, 32\n"
	    "je      .L_win64_args_70\n"
	    "test    dl, dl\n"
	    "je      .L_win64_args_82\n"
	    "mov     edx, r9d\n"
	    "inc     r9d\n"
	    "mov     qword [rax + 8*rdx], rsi\n"
	    "jmp     .L_win64_args_82\n"
	".L_win64_args_65:\n"
	    "cmp     dl, 34\n"
	    "je      .L_win64_args_66\n"
	".L_win64_args_81:\n"
	    "inc     rcx\n"
	    "mov     byte [rsi], dl\n"
	    "inc     rsi\n"
	    "jmp     .L_win64_args_82\n"
	".L_win64_args_66:\n"
	    "mov     edx, ebx\n"
	    "shr     edx, 31\n"
	    "add     edx, ebx\n"
	    "sar  edx, 1\n"
	    "neg     edx\n"
	    "movsxd  rdx, edx\n"
	    "test    bl, 1\n"
	    "jne     .L_win64_args_74\n"
	    "add     rsi, rdx\n"
	    "inc     edi\n"
	    "jmp     .L_win64_args_75\n"
	".L_win64_args_74:\n"
	    "mov     byte [rdx + rsi - 1], 34\n"
	    "add     rsi, rdx\n"
	".L_win64_args_75:\n"
	    "lea     rbx, [rcx + 1]\n"
	    "cmp     byte [rcx + 1], 34\n"
	    "jne     .L_win64_args_76\n"
	".L_win64_args_77:\n"
	    "inc     edi\n"
	    "cmp     edi, 3\n"
	    "jne     .L_win64_args_79\n"
	    "mov     byte [rsi], 34\n"
	    "inc     rsi\n"
	    "xor     edi, edi\n"
	".L_win64_args_79:\n"
	    "lea     rcx, [rbx + 1]\n"
	    "cmp     byte [rbx + 1], 34\n"
	    "mov     rbx, rcx\n"
	    "je      .L_win64_args_77\n"
	    "jmp     .L_win64_args_80\n"
	".L_win64_args_76:\n"
	    "mov     rcx, rbx\n"
	".L_win64_args_80:\n"
	    "cmp     edi, 2\n"
	    "cmove   edi, r8d\n"
	    "jmp     .L_win64_args_82\n"
	".L_win64_args_83:\n"
	    "mov     byte [rsi], 0\n"
	    "mov     ecx, r9d\n"
	    "lea     rcx, [rax + 8*rcx]\n"
	".L_win64_args_84:\n"
	    "mov     qword [rcx], 0\n"
	    "mov     dword [r14], r9d\n"
	".L_win64_args_85:\n"
	    "add     rsp, 40\n"
	    "pop     rbx\n"
	    "pop     rdi\n"
	    "pop     rsi\n"
	    "pop     r14\n"
	    "ret\n\n"
    "global _nibble_#writeout\n"
    "_nibble_#writeout:\n"
    "    push rbp\n"
    "    mov rbp, rsp\n"
    "    sub rsp, 16 + 32             ; Alloc space for locals and shadow space\n"
    "                                 ; buf: ^char (rbp + 16), size: usize (rbp + 24), bytes_written: u32 (rbp - 8)\n"
    "    ; Spill params\n"
    "    mov qword [rbp + 16], rcx    ; Spill buf\n"
    "    mov qword [rbp + 24], rdx    ; Spill size\n\n"
    "    ; hStdOut = GetStdHandle(STD_OUTPUT_HANDLE)\n"
    "    mov ecx, -11\n"
    "    call GetStdHandle            ; rax = stdout handle\n\n"
    "    ; WriteFile(hStdOut, buf, size, &bytes_written, 0)\n"
    "    mov rcx, rax\n"
    "    mov rdx, qword [rbp + 16]    ; rdx = buf\n"
    "    mov r8, qword [rbp + 24]     ; r8 = size\n"
    "    lea r9, [rbp - 8]            ; r9 = ^bytes_written\n"
    "    sub rsp, 8 + 8               ; Space for 5th stack arg and alignment (8 pad, 8 5th arg, 32 shadow)\n"
    "    mov qword[rsp + 32], 0       ; last arg is 0\n"
    "    call WriteFile\n"
    "    mov eax, dword [rbp - 8]     ; Return bytes_written\n"
    "    mov rsp, rbp\n"
    "    pop rbp\n"
    "    ret\n\n"
    "global _nibble_#readin\n"
    "_nibble_#readin:\n"
    "    push rbp\n"
    "    mov rbp, rsp\n"
    "    sub rsp, 16 + 32             ; Alloc space for locals and shadow space\n"
    "                                 ; buf: ^char (rbp + 16), size: usize (rbp + 24), bytes_read: u32 (rbp - 8)\n"
    "    ; Spill params\n"
    "    mov qword [rbp + 16], rcx    ; Spill buf\n"
    "    mov qword [rbp + 24], rdx    ; Spill size\n\n"
    "    ; hStdOut = GetStdHandle(STD_INPUT_HANDLE)\n"
    "    mov ecx, -10\n"
    "    call GetStdHandle            ; rax = stdin handle\n\n"
    "    ; ReadFile(hStdIn, buf, size, &bytes_read, 0)\n"
    "    mov rcx, rax\n"
    "    mov rdx, qword [rbp + 16]    ; rdx = buf\n"
    "    mov r8, qword [rbp + 24]     ; r8 = size\n"
    "    lea r9, [rbp - 8]            ; r9 = ^bytes_read\n"
    "    sub rsp, 8 + 8               ; Space for 5th stack arg and alignment (8 pad, 8 5th arg, 32 shadow)\n"
    "    mov qword[rsp + 32], 0       ; last arg is 0\n"
    "    call ReadFile\n"
    "    mov eax, dword [rbp - 8]     ; Return bytes_read\n"
    "    mov rsp, rbp\n"
    "    pop rbp\n"
    "    ret\n\n";

X64_Target x64_target;

bool init_x64_target(OS target_os)
{
    x64_target.os = target_os;

    switch (target_os) {
    case OS_LINUX:
        x64_target.num_arg_regs = ARRAY_LEN(x64_linux_arg_regs);
        x64_target.arg_regs = x64_linux_arg_regs;

        x64_target.num_leaf_scratch_regs = ARRAY_LEN(x64_linux_leaf_scratch_regs);
        x64_target.leaf_scratch_regs = x64_linux_leaf_scratch_regs;

        x64_target.num_nonleaf_scratch_regs = ARRAY_LEN(x64_linux_nonleaf_scratch_regs);
        x64_target.nonleaf_scratch_regs = x64_linux_nonleaf_scratch_regs;

        x64_target.caller_saved_reg_mask = x64_linux_caller_saved_reg_mask;
        x64_target.arg_reg_mask = x64_linux_arg_reg_mask;

        x64_target.startup_code = x64_linux_startup_code;
        return true;
    case OS_WIN32:
        x64_target.num_arg_regs = ARRAY_LEN(x64_windows_arg_regs);
        x64_target.arg_regs = x64_windows_arg_regs;

        x64_target.num_leaf_scratch_regs = ARRAY_LEN(x64_windows_leaf_scratch_regs);
        x64_target.leaf_scratch_regs = x64_windows_leaf_scratch_regs;

        x64_target.num_nonleaf_scratch_regs = ARRAY_LEN(x64_windows_nonleaf_scratch_regs);
        x64_target.nonleaf_scratch_regs = x64_windows_nonleaf_scratch_regs;

        x64_target.caller_saved_reg_mask = x64_windows_caller_saved_reg_mask;
        x64_target.arg_reg_mask = x64_windows_arg_reg_mask;

        x64_target.startup_code = x64_windows_startup_code;
        return true;
    default:
        return false;
    }
}

bool X64_is_caller_saved_reg(X64_Reg reg)
{
    return u32_is_bit_set(x64_target.caller_saved_reg_mask, reg);
}

bool X64_is_callee_saved_reg(X64_Reg reg)
{
    return !u32_is_bit_set(x64_target.caller_saved_reg_mask, reg);
}

bool X64_is_arg_reg(X64_Reg reg)
{
    return u32_is_bit_set(x64_target.arg_reg_mask, reg);
}
