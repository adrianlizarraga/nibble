
@exported
proc print_out(format : [] char, vargs : ..any) => s64 {
    var n : s64 = 0;
    var buf : [128] char;
    var dst : FileBuffer;

    dst.buf = buf :> []char;
    dst.idx = 0;

    // TODO: variadic structs should just be slices
    var args : []any;
    args.data = vargs.data;
    args.length = vargs.length;

    n = print_out_internal(output_to_file, ^dst, format, args);

    return n;
}

struct FileBuffer {
    buf : []char;
    idx : s64;
}

struct PrintState {
    count : u64;
    arg : ^void;
    put_char : PutCharProc;
}

typedef PutCharProc = proc(^void, char) => bool;

proc print_out_internal(put_char : PutCharProc, arg : ^void, format : []char, args : []any) => s64 {
    var state : PrintState;
    state.count = 0;
    state.arg = arg;
    state.put_char = put_char;

    for (var i := 0; i < format.length; ) {
        var c := format[i];

        if (c == '%') {
            i = i + 1;
        }
        else {
            put_char_wrapper(^state, c);
            i = i + 1;
        }
    }

    return state.count;
}

proc put_char_wrapper(state : ^PrintState, c : char) => bool {
    var r : bool = 1;

    if (state.put_char) {
        r = state.put_char(state.arg, c);
    }

    if (r && c) {
        state.count = state.count + 1;
    }

    return r;
}

proc output_to_file(data : ^void, c : char) => bool {
    var ret : bool = 1;
    var dst : ^FileBuffer = data :> ^FileBuffer;
    var write_char := c;

    if (dst.idx < dst.buf.length) {
        if (write_char) {
            dst.buf[dst.idx] = c;
            dst.idx = dst.idx + 1;
        }
    }
    else {
        if (!flush_file_buffer(dst)) {
            return 0;
        }

        if (write_char) {
            dst.buf[dst.idx] = c;
            dst.idx = dst.idx + 1;
        }
    }

    if (!c) {
        ret = flush_file_buffer(dst);
    }

    return ret;
}

proc flush_file_buffer(fb : ^FileBuffer) => bool {
    var n : s64 = #writeout(fb.buf, fb.idx);

    if (n == fb.idx) {
        fb.idx = 0;
        return 1;
    }

    return 0;
}

