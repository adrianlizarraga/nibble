proc cstr_len(s : ^char) => usize
{
    if (!s) {
        return 0;
    }

    var count : usize = 0;

    while (*s) {
        s = s + 1;
        count = count + 1;
    }

    return count;
}

proc print_char_val(buf: ^char, size: usize, c: char) => usize
{
    var l : usize = 0;
    var d : int = c;

    do {
        // TODO: Support % operator
        //buf[size - 1 - l] = (d % 10) + '0';
        //d = d / 10;

        var d_next := d / 10;
        var r := d - (d_next * 10);
        buf[size - 1 - l] = r + '0';
        d = d_next;

        l = l + 1;
    } while (d && l < size);

    return l;
}

proc print_chars(buf: ^char, size: usize)
{
    var tmp : [32]char = {0};
    var tmp_end : ^char = tmp + 31;

    *tmp_end = '\n';

    var i : usize = 0;
    while (i < size) {
        var l := print_char_val(tmp, 31, buf[i]);
        #writeout(tmp_end - l, l + 1);
        i = i + 1;
    }
}

proc main(argc : int, argv : ^^char) => int
{
    var i := 0;
    var ln : char = '\n';

    while (i < argc) {
        var s : ^char = argv[i];
        #writeout(s, cstr_len(s));
        #writeout(^ln, 1);
        i = i + 1;
    }

    var buf : [8]char = {0};
    var num_bytes_read : ssize = 0;

    // Read user input
    num_bytes_read = #readin(buf, 8);

    // Print ASCII value of every read character.
    if ( num_bytes_read >= 0) {
        print_chars(buf, num_bytes_read);
    }
    else {
        #writeout("ERROR\n", 6); 
    }

    return num_bytes_read;
}

